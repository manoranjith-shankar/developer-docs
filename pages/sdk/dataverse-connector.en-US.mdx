import { Callout } from 'nextra-theme-docs';

# Getting started with Dataverse SDK

A quick guide to get you started with the dataverse runtime connector SDK.

After reading this guide, you will be able to connect with the dataverse browser extension,
create data streams, load data streams, update data streams, and monetize data.

<Callout type="warning" emoji="⚠️">
  Before we start, please make sure you have created your dataverse-app and
  defined the data models you want to use in your app using the
  [create-dataverse-app framework](/cli-and-tools/create-dataverse-app).
</Callout>

## Prerequisites

### Install Data wallet

Data Wallet is a Chrome browser extension. we need to make sure it's installed and
it's updated to the latest version before we proceed with the development.

[Download on chrome store](https://chrome.google.com/webstore/detail/dataverse/kcigpjcafekokoclamfendmaapcljead)

![quickstart-1](/images/sdk/chrome-store.png)
You may sign in with MetaMask or Particle Social Account and create a new identity.

### Install JS SDK

```bash
npm install @dataverse/runtime-connector
```

## Step 1: Initialize the connector

```javascript
// After installation, you can import the SDK and initialize the runtime connector.
/** Import Runtime Connector SDK */
import { RuntimeConnector, Extension } from '@dataverse/runtime-connector';

/** Initialize the runtime connector class object */
const runtimeConnector = new RuntimeConnector(Extension);
```

The `Extension` specifies the target that runtime connector will connect to.
Currently, the dataverseos kernel is running in the browser extension, so we use `Extension` as the target.

## Step 2: Connect with user wallet

```javascript
import React, { useState } from 'react';

/** Import Runtime Connector SDK and types */
import {
  RuntimeConnector,
  Extension,
  WALLET
} from "@dataverse/runtime-connector";

/**
 * Initialize the Runtime Connector
 */
const runtimeConnector: RuntimeConnector = new RuntimeConnector(Extension);

const App: React.FC = () => {
  const [wallet, setWallet] = useState<WALLET>();

  const connectWallet = async () => {
    try {
      const res = await runtimeConnector.connectWallet();
      setWallet(res.wallet);
      return(res.address);
    } catch (error) {
      console.error(error);
    }
  };

  return (
    <button onClick={connectWallet}>
      Connect Wallet
    </button>
  );
};

export default App;
```

The `connectWallet` function receive an optional parameter `wallet` to specify which wallet to use.

```js
enum WALLET {
  METAMASK = "MetaMask",
  PARTICLE = "Particle"
}
```

if not specified(pass in no parameters), the function will open an option page for users to choose which wallet to use.

<img src="/images/sdk/option-page.png" className="mx-auto my-2.5" width="90%" />

## Step 3: Create capability

```js
import { RESOURCE } from '@dataverse/runtime-connector';

const app = 'YOUR_APP_NAME';

const createCapability = async () => {
  const pkh = await runtimeConnector.createCapability({
    app,
    resource: RESOURCE.CERAMIC,
    wallet,
  });
  return pkh;
};
```

This will open a popup window to ask for user permission to connect with the application.
We use Sign-in-with-Ethereum signatures to authenticate the user approvement.
The popup shall be like this:

<div className="flex">
  <img src="/images/sdk/siwe1.png" width="50%" />
  <img src="/images/sdk/siwe2.png" width="50%" />
</div>

## Step 4: Create a data stream

Data stream is the smallest unit of data in our system.
Unlike IPFS CID which cannot be changed after upload, data streams can be updated and linked between each other.
Each data stream belongs to a data model. For example, if you have created a data model called `post` as a data structure for posts in a social app

```graphql
type post @createModel(accountRelation: LIST, description: "post") {
  author: DID! @documentAccount # DID of the user who created this post
  version: CommitID! @documentVersion
  appVersion: String! @string(maxLength: 100)
  text: String @string(maxLength: 300000000) # text content of the post
  images: [String] @list(maxLength: 10000000) @string(maxLength: 2000000) # images of the post
  videos: [String] @list(maxLength: 10000000) @string(maxLength: 2000000) # videos of the post
  options: String @string(maxLength: 300000000)
  createdAt: DateTime! # time when the post is created
  updatedAt: DateTime! # time when the post is updated
}
```

`createStream` under this `post` model is how you create posts.

```javascript
const encrypted = JSON.stringify({
  text: false,
  images: false,
  videos: false,
});

await runtimeConnector.createStream({
  modelId,
  streamContent: {
    appVersion: '0.0.1',
    text: 'hello',
    images: [
      'https://bafkreib76wz6wewtkfmp5rhm3ep6tf4xjixvzzyh64nbyge5yhjno24yl4.ipfs.w3s.link',
    ],
    videos: [],
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString(),
    encrypted,
  },
});
```

return example

```json
{
  "pkh": "did:pkh:eip155:137:0xb4D93398f6F3FB5EE4436D1aE93b32d65693a799",
  "app": "fxy001",
  "modelId": "kjzl6hvfrbw6c7gkypf9654o0vu1jd1q85fcnyrpc1koobuys71zhp0m7kbmrvs",
  "streamId": "kjzl6kcym7w8y7nfklssfuv1o8p32use2psysup1khcm6k6bfzpcm3bb8fcc2iu",
  "streamContent": {
    "content": {
      "text": "hello",
      "images": [
        "https://bafkreib76wz6wewtkfmp5rhm3ep6tf4xjixvzzyh64nbyge5yhjno24yl4.ipfs.w3s.link"
      ],
      "videos": [],
      "createdAt": "2023-06-09T06:18:00.716Z",
      "encrypted": "{\"text\":false,\"images\":false,\"videos\":false}",
      "updatedAt": "2023-06-09T06:18:00.716Z",
      "appVersion": "0.0.1"
    },
    "file": {
      "appVersion": "0.2.0",
      "contentId": "kjzl6kcym7w8y7nfklssfuv1o8p32use2psysup1khcm6k6bfzpcm3bb8fcc2iu",
      "contentType": "kjzl6hvfrbw6c7gkypf9654o0vu1jd1q85fcnyrpc1koobuys71zhp0m7kbmrvs",
      "comment": { "mirrorName": "fxy001_post", "note": "", "tags": [] },
      "fileType": 0,
      "createdAt": "2023-06-09T06:18:02.556Z",
      "updatedAt": "2023-06-09T06:18:02.556Z",
      "indexFileId": "kjzl6kcym7w8y50qam78fms8q5vneg9zuxm8advu3v5b6ke24opn6fv5muczw63"
    }
  }
}
```

<Callout emoji="❗">
  To create a data stream under a specific model, you need to specify the model
  id and ensure your app has the capability to write data under this model. if
  not, please use `createCapability` to create a capability for the model first.
</Callout>

## Step 5: Load a data stream

You can load a stream's content by stream id.

```javascript
await runtimeConnector.loadStream({
  streamId: 'kjzl6kcym7w8ya8g9cj5764kll6veldqws40ub29r1odut2pxiqxet80sl9p6th', // for example
});
```

You can also load multiple streams under a model.

```javascript
await runtimeConnector.loadStreamsBy({
  modelId,
  pkh: 'did:pkh:eip155:137:0x5915e293823FCa840c93ED2E1E5B4df32d699999',
});
```

The `pkh` is optional. If not specified, will return all streams under the model.

## Step 6: Update a data stream

```javascript
const date = new Date().toISOString();

const encrypted = JSON.stringify({
  text: true,
  images: true,
  videos: false,
});

const res = await runtimeConnector.updateStream({
  streamId,
  streamContent: {
    appVersion: '0.0.1',
    text: 'hello world!',
    images: [
      'https://bafkreib76wz6wewtkfmp5rhm3ep6tf4xjixvzzyh64nbyge5yhjno24yl4.ipfs.w3s.link',
    ],
    videos: [],
    createdAt: date,
    updatedAt: date,
    encrypted,
  },
});
```

`updateStream` shares the same parameters as `createStream`, except the `streamId` is required.
and the return value is the same as `createStream`.

## Step 7: Monetize

```javascript
import { Currency } from "@dataverse/runtime-connector";

const res = await runtimeConnector.monetizeFile({
  streamId,
  datatokenVars: {
    profileId: "LENS_HANDLE_PROFILE_ID",
    collectLimit: 100,
    amount: 0.0001,
    currency: Currency.WMATIC,
  },
  storageProvider,
  decryptionConditions: [
    ...
  ],
});
```

**Why lens profile is needed to monetize data?**

To put it simply, data monetization is to deploy a collection of NFTs on the blockchain.
and use the NFT as access credentials to the data. In this case, we use lens protocol to
turn off-chain data into on-chain `lens post`, and program the NFT smart contract around
the post.

**Explain `decryptionConditions`**

`decryptionConditions` specifies a set of conditions to limit the access to the data.
For example

```javascript
[
  {
    conditionType: 'evmBasic',
    contractAddress: '',
    standardContractType: '',
    chain: 'filecoin',
    method: '',
    parameters: [':userAddress'],
    returnValueTest: {
      comparator: '=',
      value: '0x3c6216caE32FF6691C55cb691766220Fd3f55555',
    },
  },
];
```

This condition specifies that the data can only be accessed by the
wallet address `0x3c6216caE32FF6691C55cb691766220Fd3f55555` on filecoin chain.

## Step 8: Unlock

```javascript
await runtimeConnector.unlock({
  indexFileId:
    'kjzl6kcym7w8y5xf0j7kmies5i30f86xlerbfp42qnxju2vfno1io6i04sy2p2d',
});
```

This will send a transaction to mint a NFT to the user's wallet address.
The NFT is the access credential to the data.

<Callout>
  `monetize` and `unlock` functions are currently on Mumbai testnet.
</Callout>
